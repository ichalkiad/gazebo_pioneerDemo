<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />


<script src="https://static.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
<script type="text/javascript" src="https://static.robotwebtools.org/roslibjs/current/roslib.js"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vsup@latest"></script>

<style>
    body {
      font-family: sans-serif;
    }
  </style>

<script>
  // Connecting to ROS
  // -----------------
  var ros = new ROSLIB.Ros();

  // If there is an error on the backend, an 'error' emit will be emitted.
  ros.on('error', function(error) {
    document.getElementById('connecting').style.display = 'none';
    document.getElementById('connected').style.display = 'none';
    document.getElementById('closed').style.display = 'none';
    document.getElementById('error').style.display = 'inline';
    console.log(error);
  });

  // Find out exactly when we made a connection.
  ros.on('connection', function() {
    console.log('Connection made!');
    document.getElementById('connecting').style.display = 'none';
    document.getElementById('error').style.display = 'none';
    document.getElementById('closed').style.display = 'none';
    document.getElementById('connected').style.display = 'inline';
  });

  ros.on('close', function() {
    console.log('Connection closed.');
    document.getElementById('connecting').style.display = 'none';
    document.getElementById('connected').style.display = 'none';
    document.getElementById('closed').style.display = 'inline';
  });

  // Create a connection to the rosbridge WebSocket server.
  ros.connect('ws://localhost:9090');

  //Subscribing to  Topic
  //----------------------
  var listener = new ROSLIB.Topic({
    ros : ros,
    name : '/uncertain',
    messageType : 'p3dx_description/UncertainMsg'
  });

  var msg = [];
  // Callback to be called every time a message is published on this topic.
  listener.subscribe(function(message) {
  console.log('Received message on ' + listener.name + ': ' + message.UncertainList);
        msg = [];
        msg[0] = message.UncertainList[0];
        msg[1] = message.UncertainList[1];
        msg[2] = message.UncertainList[2];
  msg[3] = message.UncertainList[3];
  console.log(msg)

    // If desired, we can unsubscribe from the topic as well.
    //listener.unsubscribe();
  });

</script>
<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
  <h1>Simple roslib Example</h1>
  <p>Run the following commands in the terminal then refresh this page. Check the JavaScript
    console for the output.</p>
  <ol>
    <li><tt>roscore</tt></li>
    <li><tt>rostopic pub /listener std_msgs/String "Hello, World"</tt></li>
    <li><tt>rostopic echo /cmd_vel</tt></li>
    <li><tt>rosrun rospy_tutorials add_two_ints_server</tt></li>
    <li><tt>roslaunch rosbridge_server rosbridge_websocket.launch</tt></li>
  </ol>
  <div id="statusIndicator">
    <p id="connecting">
      Connecting to rosbridge...
    </p>
    <p id="connected" style="color:#00D600; display:none">
      Connected
    </p>
    <p id="error" style="color:#FF0000; display:none">
      Error in the backend!
    </p>
    <p id="closed" style="display:none">
      Connection closed.
    </p>
  </div>

  <div>
    <script>
 
      d3.csv("aster_data.csv").then(function(data) {

        data = data.map(function(d) {
           return  {
                 id : d.id,
                 Direction : +d.score,
                 Uncertainty : +d.weight,
                 startAngle : +d.startAngle,
                 endAngle : +d.endAngle,
                 label : d.label
                 }
            });

      
   
        var id   = d3.extent(data.map(function(d) { return d.id; }));
        var sAngle   = d3.extent(data.map(function(d) { return d.startAngle; }));
        var eAngle   = d3.extent(data.map(function(d) { return d.endAngle; }));

        var vDom = d3.extent(data.map(function(d) { return d.Direction; }));
        var uDom = d3.extent(data.map(function(d) { return d.Uncertainty; }));

        uDom[0] = msg[0];      
        uDom[1] = msg[1];      
        uDom[2] = msg[2];      
        uDom[3] = msg[3];      
        console.log(uDom[0]);

        var quantization = vsup.quantization().branching(2).layers(3).valueDomain(vDom).uncertaintyDomain(uDom);
        var scale = vsup.scale().quantize(quantization).range(d3.interpolateViridis);

        var squareQuantization = vsup.squareQuantization().n(4).valueDomain(vDom).uncertaintyDomain(uDom);
        var squareScale = vsup.scale().quantize(squareQuantization).range(d3.interpolateViridis);

        var simpleScale = d3.scaleQuantize().domain([0, 1]).range(d3.quantize(d3.interpolateViridis, 4));
        var body = d3.select("body");

        var w = 860;
        var h = 440;
        radius = Math.min(w, h) / 2,
        innerRadius = 0.2 * radius;

     
      
        makeVSUP(body.append("svg"), w, h, scale, simpleScale, data, "arc");

      });


      function makeVSUP(svg, w, h, scale, simpleScale, data, type) {
                 
        var pie = d3.pie()
                    .sort(null)
                    .value(function(d) { return d.Uncertainty; } );

        var arc = d3.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(function (d) { 
                            return (radius - innerRadius) * d.data.Uncertainty + innerRadius; 
                        })
                        .startAngle(function(d) { return d.data.startAngle; })
                        .endAngle(function(d) { return d.data.endAngle; });



        var svg = d3.select("body").append("svg")
                                   .attr("width", w)
                                   .attr("height", h)
                                   .append("g")
                                   .attr("transform", "translate(5,150)");

      
              
        
        var arcEnter = svg.selectAll(".solidArc")
            .data(pie(data))
            .enter().append("g")
            .classed("solidArc", true)
            .attr("transform", "translate(200,50)");

        arcEnter.append("path")
            .attr("fill", function(d) { return scale(d.data.Direction, d.data.Uncertainty); })
            .attr("id", function(d) { return d.data.id; })
            .attr("stroke", "gray")
            .attr("d", arc);


        /*
        arcEnter.append("text")
                .style("font-size", 13)
                .style("text-anchor", "middle")
                .attr("y", -10)
                .attr("xlink:href", function(d){return d.data.id;}) 
                .text(function(d) {return d.data.label;})
                .attr("transform", function(d) {
                        return "rotate(0.7)translate(0,0)"});
        */
      
       makeLegend(svg, w, scale, data, type);        
     
      
      }

      function makeLegend(svg, w, scale, data, type) {

        var legend = type === "arc" ? vsup.legend.arcmapLegend() : vsup.legend.simpleLegend();

        if (type==="arc") {
            legend
                .scale(scale)
                .size(160)
                .x(500)
                .y(-40)
                .vtitle("Direction")
                .utitle("Danger of collision");
        } else {
             legend
                .scale(scale)
                .size(160)
                .height(40)
                .x(150)
                .y(60)
                .title("Danger of collision");
        }
        svg.append("g").call(legend)
      }
      
        

    </script>
    </div>
  
</body>
</html>
